From: Michael Terry <michael.terry@canonical.com>
Date: Fri, 20 Dec 2019 16:45:51 +0100
Subject: Add support to passwd for updating libnss-extrausers locations

---
 lib/commonio.c |  2 ++
 lib/defines.h  |  8 ++++++++
 src/passwd.c   | 65 +++++++++++++++++++++++++++++++++++++++++++++++++++++++++-
 src/usermod.c  | 48 +++++++++++++++++++++++++++++++++++++++++++
 4 files changed, 122 insertions(+), 1 deletion(-)

diff --git a/lib/commonio.c b/lib/commonio.c
index 9f6ceca..008691f 100644
--- a/lib/commonio.c
+++ b/lib/commonio.c
@@ -419,6 +419,7 @@ int commonio_lock (struct commonio_db *db)
 	int i;
 
 #ifdef HAVE_LCKPWDF
+  if (strncmp(db->filename, "/etc/", 5) == 0) {
 	/*
 	 * Only if the system libc has a real lckpwdf() - the one from
 	 * lockpw.c calls us and would cause infinite recursion!
@@ -448,6 +449,7 @@ int commonio_lock (struct commonio_db *db)
 		ulckpwdf ();
 		return 0;		/* failure */
 	}
+  } /* strncmp(db->filename, "/etc/", 5) == 0 */
 #endif				/* !HAVE_LCKPWDF */
 
 	/*
diff --git a/lib/defines.h b/lib/defines.h
index 2fb1b56..ffa8b6a 100644
--- a/lib/defines.h
+++ b/lib/defines.h
@@ -316,6 +316,14 @@ char *strchr (), *strrchr (), *strtok ();
 #endif
 #endif
 
+#ifndef EXTRAUSERS_PASSWD_FILE
+#define EXTRAUSERS_PASSWD_FILE "/var/lib/extrausers/passwd"
+#endif
+
+#ifndef EXTRAUSERS_SHADOW_FILE
+#define EXTRAUSERS_SHADOW_FILE "/var/lib/extrausers/shadow"
+#endif
+
 #ifndef NULL
 #define NULL ((void *) 0)
 #endif
diff --git a/src/passwd.c b/src/passwd.c
index 13619b1..bfe0aea 100644
--- a/src/passwd.c
+++ b/src/passwd.c
@@ -559,8 +559,15 @@ static void update_noshadow (void)
 {
 	const struct passwd *pw;
 	struct passwd *npw;
+	bool try_extrausers = strcmp (pw_dbname (), EXTRAUSERS_PASSWD_FILE) != 0 &&
+	                      access (EXTRAUSERS_PASSWD_FILE, F_OK) == 0;
 
 	if (pw_lock () == 0) {
+		if (try_extrausers) {
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			update_noshadow ();
+			return;
+		}
 		(void) fprintf (stderr,
 		                _("%s: cannot lock %s; try again later.\n"),
 		                Prog, pw_dbname ());
@@ -568,6 +575,20 @@ static void update_noshadow (void)
 	}
 	pw_locked = true;
 	if (pw_open (O_CREAT | O_RDWR) == 0) {
+		if (try_extrausers) {
+			if (pw_unlock () == 0) {
+				(void) fprintf (stderr,
+				                _("%s: failed to unlock %s\n"),
+				                Prog, pw_dbname ());
+				SYSLOG ((LOG_ERR, "failed to unlock %s", pw_dbname ()));
+				/* continue */
+			}
+			pw_locked = false;
+
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			update_noshadow ();
+			return;
+		}
 		(void) fprintf (stderr,
 		                _("%s: cannot open %s\n"),
 		                Prog, pw_dbname ());
@@ -576,6 +597,21 @@ static void update_noshadow (void)
 	}
 	pw = pw_locate (name);
 	if (NULL == pw) {
+		if (try_extrausers) {
+			(void) pw_close ();
+			if (pw_unlock () == 0) {
+				(void) fprintf (stderr,
+				                _("%s: failed to unlock %s\n"),
+				                Prog, pw_dbname ());
+				SYSLOG ((LOG_ERR, "failed to unlock %s", pw_dbname ()));
+				/* continue */
+			}
+			pw_locked = false;
+
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			update_noshadow ();
+			return;
+		}
 		(void) fprintf (stderr,
 		                _("%s: user '%s' does not exist in %s\n"),
 		                Prog, name, pw_dbname ());
@@ -613,8 +649,15 @@ static void update_shadow (void)
 {
 	const struct spwd *sp;
 	struct spwd *nsp;
+	bool try_extrausers = strcmp (spw_dbname (), EXTRAUSERS_SHADOW_FILE) != 0 &&
+	                      access (EXTRAUSERS_SHADOW_FILE, F_OK) == 0;
 
 	if (spw_lock () == 0) {
+		if (try_extrausers) {
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			update_shadow ();
+			return;
+		}
 		(void) fprintf (stderr,
 		                _("%s: cannot lock %s; try again later.\n"),
 		                Prog, spw_dbname ());
@@ -622,6 +665,20 @@ static void update_shadow (void)
 	}
 	spw_locked = true;
 	if (spw_open (O_CREAT | O_RDWR) == 0) {
+		if (try_extrausers) {
+			if (spw_unlock () == 0) {
+				(void) fprintf (stderr,
+						        _("%s: failed to unlock %s\n"),
+						        Prog, spw_dbname ());
+				SYSLOG ((LOG_ERR, "failed to unlock %s", spw_dbname ()));
+				/* continue */
+			}
+			spw_locked = false;
+
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			update_shadow ();
+			return;
+		}
 		(void) fprintf (stderr,
 		                _("%s: cannot open %s\n"),
 		                Prog, spw_dbname ());
@@ -632,7 +689,9 @@ static void update_shadow (void)
 	if (NULL == sp) {
 		/* Try to update the password in /etc/passwd instead. */
 		(void) spw_close ();
-		update_noshadow ();
+		if (!try_extrausers) {
+			update_noshadow ();
+		}
 		if (spw_unlock () == 0) {
 			(void) fprintf (stderr,
 			                _("%s: failed to unlock %s\n"),
@@ -641,6 +700,10 @@ static void update_shadow (void)
 			/* continue */
 		}
 		spw_locked = false;
+		if (try_extrausers) {
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			update_shadow ();
+		}
 		return;
 	}
 	nsp = __spw_dup (sp);
diff --git a/src/usermod.c b/src/usermod.c
index 05b9871..fb833e1 100644
--- a/src/usermod.c
+++ b/src/usermod.c
@@ -1566,7 +1566,16 @@ static void close_files (void)
  */
 static void open_files (void)
 {
+	bool try_extrausers = strcmp (pw_dbname (), EXTRAUSERS_PASSWD_FILE) != 0 &&
+	                      access (EXTRAUSERS_PASSWD_FILE, F_OK) == 0;
+
 	if (pw_lock () == 0) {
+		if (try_extrausers) {
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			open_files ();
+			return;
+		}
 		fprintf (stderr,
 		         _("%s: cannot lock %s; try again later.\n"),
 		         Prog, pw_dbname ());
@@ -1574,12 +1583,29 @@ static void open_files (void)
 	}
 	pw_locked = true;
 	if (pw_open (O_CREAT | O_RDWR) == 0) {
+		if (try_extrausers) {
+			pw_unlock ();
+			pw_locked = false;
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			open_files ();
+			return;
+		}
 		fprintf (stderr,
 		         _("%s: cannot open %s\n"),
 		         Prog, pw_dbname ());
 		fail_exit (E_PW_UPDATE);
 	}
 	if (is_shadow_pwd && (spw_lock () == 0)) {
+		if (try_extrausers) {
+			pw_close ();
+			pw_unlock ();
+			pw_locked = false;
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			open_files ();
+			return;
+		}
 		fprintf (stderr,
 		         _("%s: cannot lock %s; try again later.\n"),
 		         Prog, spw_dbname ());
@@ -1587,6 +1613,17 @@ static void open_files (void)
 	}
 	spw_locked = true;
 	if (is_shadow_pwd && (spw_open (O_CREAT | O_RDWR) == 0)) {
+		if (try_extrausers) {
+			pw_close ();
+			pw_unlock ();
+			spw_unlock ();
+			pw_locked = false;
+			spw_locked = false;
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			open_files ();
+			return;
+		}
 		fprintf (stderr,
 		         _("%s: cannot open %s\n"),
 		         Prog, spw_dbname ());
@@ -1675,11 +1712,22 @@ static void usr_update (void)
 	struct spwd spent;
 	const struct spwd *spwd = NULL;
 
+	bool try_extrausers = strcmp (pw_dbname (), EXTRAUSERS_PASSWD_FILE) != 0 &&
+	                      access (EXTRAUSERS_PASSWD_FILE, F_OK) == 0;
+
 	/*
 	 * Locate the entry in /etc/passwd, which MUST exist.
 	 */
 	pwd = pw_locate (user_name);
 	if (NULL == pwd) {
+		if (try_extrausers) {
+			close_files ();
+			pw_setdbname (EXTRAUSERS_PASSWD_FILE);
+			spw_setdbname (EXTRAUSERS_SHADOW_FILE);
+			open_files ();
+			usr_update ();
+			return;
+		}
 		fprintf (stderr,
 		         _("%s: user '%s' does not exist in %s\n"),
 		         Prog, user_name, pw_dbname ());
